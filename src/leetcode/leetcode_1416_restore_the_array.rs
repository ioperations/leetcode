use std::collections::HashMap;

// A program was supposed to print an array of integers. The program forgot to
// print whitespaces and the array is printed as a string of digits s and all we
// know is that all integers in the array were in the range [1, k] and there are
// no leading zeros in the array.
//
// Given the string s and the integer k, return the number of the possible
// arrays that can be printed as s using the mentioned program. Since the answer
// may be very large, return it modulo 109 + 7.
#[allow(unused)]
struct Solution;

impl Solution {
    #[allow(unused)]
    pub fn number_of_arrays(s: &str, k: i32) -> i32 {
        // 1 <= s.length <= 105
        // s consists of only digits and does not contain leading zeros.
        // 1 <= k <= 109
        const MOD: i32 = 1_000_000_000 + 7;
        fn my_impl(s: &[u8], k: i32, cache: &mut HashMap<String, i32>) -> i32 {
            if s.is_empty() {
                return 1;
            }
            if s.len() == 1 {
                if s[0] == b'0' {
                    return 0;
                }

                if k >= 10 {
                    return 1;
                }

                if s[0] >= b'1' && s[0] <= (b'0' + k as u8) {
                    return 1;
                }
                return 0;
            }
            let str = std::str::from_utf8(s).unwrap().into();
            if let Some(&v) = cache.get(&str) {
                return v;
            }
            let mut ret = 0;
            for i in 1..=s.len() {
                let s1 = &s[0..i];
                let s2 = &s[i..];
                if s1[0] == b'0' {
                    continue;
                }
                let Ok(n1) = std::str::from_utf8(s1).unwrap().parse::<i32>() else {
                    continue;
                };
                if n1 > k {
                    continue;
                }
                let n2 = my_impl(s2, k, cache);
                ret += n2;
                ret %= MOD;
            }
            cache.insert(str, ret);

            ret
        }
        let mut cache = HashMap::new();
        my_impl(s.as_bytes(), k, &mut cache)
    }

    #[allow(unused)]
    pub fn number_of_arrays_dp(s: &str, k: i32) -> i32 {
        const MOD: usize = 1_000_000_007;

        let k = k as usize;
        let n = s.len();

        let s_bytes = s.as_bytes();

        let mut dp = vec![0; n + 1];
        dp[n] = 1;

        for i in (0..n).rev() {
            let mut num: usize = 0;
            for j in i..n {
                num = num * 10 + (s_bytes[j] - b'0') as usize;
                if num > k || s_bytes[i] == b'0' {
                    break;
                }
                dp[i] = (dp[i] + dp[j + 1]) % MOD;
            }
        }

        dp[0] as i32
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn case1_test() {
        let s = "1000";
        let k = 10000;
        let output = 1;
        // Explanation: The only possible array is [1000]
        let ret = Solution::number_of_arrays(s, k);
        assert_eq!(ret, output);
    }

    #[test]
    fn case2_test() {
        let s = "1000";
        let k = 10;
        let output = 0;
        // Explanation:
        // There cannot be an array that was printed this way and has all
        // integer >= 1 and <= 10.

        let ret = Solution::number_of_arrays(s, k);
        assert_eq!(ret, output);
    }

    #[test]
    fn case3_test() {
        let s = "1317";
        let k = 2000;
        let output = 8;
        // Explanation:
        // Possible arrays are
        // [1317],[131,7],[13,17],[1,317],[13,1,7],[1,31,7],[1,3,17],[1,3,1,7]

        let ret = Solution::number_of_arrays(s, k);
        assert_eq!(ret, output);
    }

    #[test]
    fn case4_test() {
        let s = "1111111111111";
        let k = 1_000_000_000;
        let output = 4076;
        // Explanation:
        // Possible arrays are
        // [1317],[131,7],[13,17],[1,317],[13,1,7],[1,31,7],[1,3,17],[1,3,1,7]

        let ret = Solution::number_of_arrays(s, k);
        assert_eq!(ret, output);
    }

    #[test]
    fn case5_test() {
        let s = "600342244431311113256628376226052681059918526204";
        let k = 703;
        let output = 411_743_991;
        // Explanation:
        // Possible arrays are
        // [1317],[131,7],[13,17],[1,317],[13,1,7],[1,31,7],[1,3,17],[1,3,1,7]

        let ret = Solution::number_of_arrays(s, k);
        assert_eq!(ret, output);
    }

    #[test]
    fn case6_test() {
        let s =  "60891074110764506172567219609341401750508439262831353078571361488325177916612640603310797328738051125\
12071784613117784120370156131727271143390462814621391437375085466486527129089676218204148839711194278\
43788392105242650103125305582045204724287392517164139508054145047774846691351834197811271878504058920\
81722854898697942317901602619966665304800128995218492689014166497572436014469666116123834734835494959\
78200470798331734489841554755573279140142704591781600812772754211140474514698195019186226117392957717\
67465181610692913394630657261319679244576374794112377444928757043153391576113123048655449597251789349\
98123753300252930705219083994166421802270021221548214867444354170640655778060881185312113449809395839\
37123361766114506545514383581314289071344709043256866468020851621270957809903109175901167078865133742\
03711135958715924199810578030416438174314577524109122162157984435188997404364386331567477891641633291\
85089278108235341126453187959658213209231528082718541167804032647814617809116605962517194455101467892\
16577367815559951311146385610133350329412255923209215813162381490287116900319718516093092405714865207\
81172995301551160381559184593411978768539680668584441454266616797841016904799616572971634809455774720\
31134393181787769961611547131035538801914634449195542356233491597278281139025634472648617199238731265\
07716496640411624387711453144614108798317421720418948569988559690177884127295239632000108810657845111\
14007451589284301555686531044533589158798389088161160310948674475371319039581862449271937765456935638\
11225365792917590311248451011496289158380533166400332281500208110659695841641582244843305138310068696\
81845922191140601988321491131346331171007641176515533147061462710454191147586323700336340753902916610\
41215446517489770514068133410313444619277091960960798466186701766975813179488144987394112566146262615\
67572606841166328751442808565913658217566270870227891467555537502942021421032130681055451651881017855\
85185273104138387000127803715302919121776013416910350918364517411172993035038177105196669145498080157\
35553818240024510302435917064052955345568188092497304002291918865326376619716492802868419747124394618\
17452379355346741676800523939528132312441191901458140083391255619391797375367401652911954189814867783\
59067479544846152150889277275888161659660731274829391821600011926640291526248351764678701898468955168\
83728221361401126484087879839724963840785728891871757240421794589921203449271458131896072125919725275\
24228344189236464144153107134824979477561831805394425137971294904533181636705793955782969127038256975\
71300118126988055344889781377788571674874261435267873212447838732360141602914710398721486977921080655\
66157825109411642102154975597419052631438018471855246603719180671336162528231388341417652188263035029\
15028213889777101461560213552369818125899641765422196185461921538232607147317465741051867326196012091\
50415019927790053104230172625514978267778348866178379671847584291064758901456793591312696001151987671\
23275375168909128812627791911116001932258619119820095014771556166881577244841576792365837753411518753\
56136239814246691813780290723836480213721681771013561403897977694558917892772218842372518674456823675\
54714532431216484520418193268641180846174029202852388921210290111192960615533885523204612685521843297\
83147743619159609143436965435996943712328816198456765166514446794706216092171922479716276861210793986\
23245392744249059381236516657455312673526520302691144721851522625181329219216042298032976975974797869\
70127851476153061164219987892835510809037910261020465907616816115991902108491448612301278162831800218\
27298616701244053423686504964772911717511207261750016224801822689389864136311903171849705788120465672\
12403838379591059969170991127540511060927781479871141509267847936608487338364133300360186308262490886\
75441769291427061895031817985677482986227133894536165245859506503771569201601161443891486747621014070\
87598735461605226440907371165195012999525711827861256043421631051576331331798832548742524128659814077\
40447341277707171369408152432688129616324483921754108487615536577269029375277385237858541745509216113\
63231778630208951430611584071962797286105558619177556708889703591867046601760399568826278715584597620\
90055018374552371173875529425120184131271999921193394635035924510996631718093797818770217915374009818\
97914121244104151519547746921910082856717700488768901462719928272844071401557623293530398171886658776\
65568529615341327367888284569191729583498601238783457110723219169393563168521310174072527173707750156\
37362918763349224625701907338462301882950273601815818861776603151109343627133197811314434331638803120\
21794348860676105632276116197609105464637177859918122022621131051118452726703167091116651021540073446\
65117225058208149244641164914630212004997392269810206214512209618413481369311682940742182451459022955\
38273638174271191286085254731371898556621933902292065209750389636348042173333495258196142043010673978\
00712849339614670596212413375184270109379070941786259541572882445321942617633050012086119158794883107\
34972813495580911292433110424091419881071242830671585460971626134921636198732767232277495001376850437\
05242571083980863269923214951679818520967810287169847192402170166079654937211648074456414858926572351\
39108365935963396568109914712513662824083483818116531439420120349569436815731050250723372161496042830\
61484103164336204542116142524516812156511398387123840540149720712139108028109929877171376811172389714\
20380635901976271727142916730239713215757583810048187400573844741251555749561700413312878200587956747\
45603037151752464118210611790342441013698411842632147096463434524681043623993500271354095926457891927\
17605839277381201516659860607611252315052205774115837644147026551251876651869127618851936242606608174\
45796951884428112103054109055317503214645858798511048233517160085915718574850511743171956305973872046\
38058016823587923989740369983981304553131319384848608739497430583150532927613484211860495413402939716\
48163041374442321185426507810147813332983017271919718652782506878321153970671175566596385389424621481\
95749091550737181871603521597599111355640310750107587256861415102292344474282162151141165552684391191\
15709959827221285286597213989739191225561126126663382426421060542959837048215937940447374148788943641\
63642310387045908475917950350978224412541853021967366738615859731617293682515340685511989787177979940\
61228499267028306789461658492183053457311087431512773659850635523192308882639872737658991099635806137\
89529214262943971905631866034429307537433855010776496431578178289080097416036549122044371148861111457\
11339924236058968648132901717896886791877383071993627450822020426779415094816219313567713605879968951\
35774471890453550747505498580784777929233411739854661607871671570039751596782341909163161527486121504\
09384848632451485322441696368719171021714454458418290886332712884245708616380910139856773896253178269\
31924002120890001011819851983926187768093213383868597856722186227026400967023410172216817041112486201\
15259159630122141143479658625810841038021822322801719228956519122258470507339170629476645272861538271\
65414729674447096536903920130207943509694472466104518301265224706452573124771373463623385377789171970\
86008551280613531786311831516850594946827185459359121179717176525280594992716887896014703362634439122\
15860873012838100918220625048243550155391065140048333167638453136829930168214652369371287724179142928\
14674976251267797953139912298854811012317310248378182092769811552331583975156152823816262516616757172\
29747401815675208810278257614879527810826938467551399182527756177726256755467332655394175185737186698\
97526881893631850255404423159584300181619478545211545356188719925036141590029179727060171400501554426\
59179862722192543621775748476331707516194554142354653185319832961537331929623472154095818483150012345\
90938875880328703454589184561788401747167695894994552344864717650658582144953132278536216790285223914\
11811750941082512951832115651535650501454703166965338107502617115418684976653681439321423101612349556\
10114219128554641625863108661020122121845170251873167253968409151309536098866710626003636265141163313\
14830780421663014955419938336074134655333710408828618460559511311830911690979329633060135725109434132\
91203110977130340107746612865720371780642341027406162954641173945501834289401084475985418835159757147\
13265505617840947619377031615750973710918002815115588019335765646336634744954168331858980953801704655\
49507993578494377103181715293843487716267771614075158801621848896301663952846565433511683125711269307\
521128969821291395581249167621924393511465088712686454185271669";
        let k = 194_014_911;
        let output = 868_612_564;
        // Explanation:
        // Possible arrays are
        // [1317],[131,7],[13,17],[1,317],[13,1,7],[1,31,7],[1,3,17],[1,3,1,7]

        let ret = Solution::number_of_arrays_dp(s, k);
        assert_eq!(ret, output);
    }
}
